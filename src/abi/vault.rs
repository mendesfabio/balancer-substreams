    const INTERNAL_ERR: &'static str = "`ethabi_derive` internal error";
    /// Contract's functions.
    #[allow(dead_code, unused_imports, unused_variables)]
    pub mod functions {
        use super::INTERNAL_ERR;
    }
    /// Contract's events.
    #[allow(dead_code, unused_imports, unused_variables)]
    pub mod events {
        use super::INTERNAL_ERR;
        #[derive(Debug, Clone, PartialEq)]
        pub struct InternalBalanceChanged {
            pub user: Vec<u8>,
            pub token: Vec<u8>,
            pub delta: substreams::scalar::BigInt,
        }
        impl InternalBalanceChanged {
            const TOPIC_ID: [u8; 32] = [
                24u8,
                225u8,
                234u8,
                65u8,
                57u8,
                230u8,
                132u8,
                19u8,
                215u8,
                208u8,
                138u8,
                167u8,
                82u8,
                231u8,
                21u8,
                104u8,
                227u8,
                107u8,
                44u8,
                91u8,
                249u8,
                64u8,
                137u8,
                51u8,
                20u8,
                194u8,
                197u8,
                176u8,
                30u8,
                170u8,
                12u8,
                66u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 3usize {
                    return false;
                }
                if log.data.len() != 32usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[ethabi::ParamType::Int(256usize)],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    user: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[1usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'user' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    token: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    delta: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_int()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_signed_bytes_be(&v)
                    },
                })
            }
        }
        impl substreams_ethereum::Event for InternalBalanceChanged {
            const NAME: &'static str = "InternalBalanceChanged";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PoolBalanceChanged {
            pub pool_id: [u8; 32usize],
            pub liquidity_provider: Vec<u8>,
            pub tokens: Vec<Vec<u8>>,
            pub deltas: Vec<substreams::scalar::BigInt>,
            pub protocol_fee_amounts: Vec<substreams::scalar::BigInt>,
        }
        impl PoolBalanceChanged {
            const TOPIC_ID: [u8; 32] = [
                229u8,
                206u8,
                36u8,
                144u8,
                135u8,
                206u8,
                4u8,
                240u8,
                90u8,
                149u8,
                113u8,
                146u8,
                67u8,
                84u8,
                0u8,
                253u8,
                151u8,
                134u8,
                141u8,
                186u8,
                14u8,
                106u8,
                75u8,
                76u8,
                4u8,
                154u8,
                191u8,
                138u8,
                248u8,
                13u8,
                174u8,
                120u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 3usize {
                    return false;
                }
                if log.data.len() < 192usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Address),
                            ),
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Int(256usize)),
                            ),
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Uint(256usize)),
                            ),
                        ],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    liquidity_provider: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'liquidity_provider' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    tokens: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            inner.into_address().expect(INTERNAL_ERR).as_bytes().to_vec()
                        })
                        .collect(),
                    deltas: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            let mut v = [0 as u8; 32];
                            inner
                                .into_int()
                                .expect(INTERNAL_ERR)
                                .to_big_endian(v.as_mut_slice());
                            substreams::scalar::BigInt::from_signed_bytes_be(&v)
                        })
                        .collect(),
                    protocol_fee_amounts: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            let mut v = [0 as u8; 32];
                            inner
                                .into_uint()
                                .expect(INTERNAL_ERR)
                                .to_big_endian(v.as_mut_slice());
                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                        })
                        .collect(),
                })
            }
        }
        impl substreams_ethereum::Event for PoolBalanceChanged {
            const NAME: &'static str = "PoolBalanceChanged";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PoolBalanceManaged {
            pub pool_id: [u8; 32usize],
            pub asset_manager: Vec<u8>,
            pub token: Vec<u8>,
            pub cash_delta: substreams::scalar::BigInt,
            pub managed_delta: substreams::scalar::BigInt,
        }
        impl PoolBalanceManaged {
            const TOPIC_ID: [u8; 32] = [
                110u8,
                220u8,
                175u8,
                98u8,
                65u8,
                16u8,
                91u8,
                76u8,
                148u8,
                194u8,
                239u8,
                219u8,
                243u8,
                166u8,
                177u8,
                36u8,
                88u8,
                235u8,
                61u8,
                7u8,
                190u8,
                58u8,
                14u8,
                129u8,
                210u8,
                75u8,
                19u8,
                196u8,
                64u8,
                69u8,
                254u8,
                122u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 4usize {
                    return false;
                }
                if log.data.len() != 64usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[
                            ethabi::ParamType::Int(256usize),
                            ethabi::ParamType::Int(256usize),
                        ],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    asset_manager: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'asset_manager' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    token: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    cash_delta: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_int()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_signed_bytes_be(&v)
                    },
                    managed_delta: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_int()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_signed_bytes_be(&v)
                    },
                })
            }
        }
        impl substreams_ethereum::Event for PoolBalanceManaged {
            const NAME: &'static str = "PoolBalanceManaged";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct PoolRegistered {
            pub pool_id: [u8; 32usize],
            pub pool_address: Vec<u8>,
            pub specialization: substreams::scalar::BigInt,
        }
        impl PoolRegistered {
            const TOPIC_ID: [u8; 32] = [
                60u8,
                19u8,
                188u8,
                48u8,
                184u8,
                232u8,
                120u8,
                197u8,
                63u8,
                210u8,
                163u8,
                107u8,
                103u8,
                148u8,
                9u8,
                192u8,
                115u8,
                175u8,
                215u8,
                89u8,
                80u8,
                190u8,
                67u8,
                216u8,
                133u8,
                135u8,
                104u8,
                233u8,
                86u8,
                251u8,
                194u8,
                14u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 3usize {
                    return false;
                }
                if log.data.len() != 32usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[ethabi::ParamType::Uint(8usize)],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    pool_address: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'pool_address' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    specialization: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                })
            }
        }
        impl substreams_ethereum::Event for PoolRegistered {
            const NAME: &'static str = "PoolRegistered";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct Swap {
            pub pool_id: [u8; 32usize],
            pub token_in: Vec<u8>,
            pub token_out: Vec<u8>,
            pub amount_in: substreams::scalar::BigInt,
            pub amount_out: substreams::scalar::BigInt,
        }
        impl Swap {
            const TOPIC_ID: [u8; 32] = [
                33u8,
                112u8,
                199u8,
                65u8,
                196u8,
                21u8,
                49u8,
                174u8,
                194u8,
                14u8,
                124u8,
                16u8,
                124u8,
                36u8,
                238u8,
                207u8,
                221u8,
                21u8,
                230u8,
                156u8,
                155u8,
                176u8,
                168u8,
                221u8,
                55u8,
                177u8,
                132u8,
                11u8,
                158u8,
                11u8,
                32u8,
                123u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 4usize {
                    return false;
                }
                if log.data.len() != 64usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[
                            ethabi::ParamType::Uint(256usize),
                            ethabi::ParamType::Uint(256usize),
                        ],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    token_in: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token_in' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    token_out: ethabi::decode(
                            &[ethabi::ParamType::Address],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token_out' from topic of type 'address': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    amount_in: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                    amount_out: {
                        let mut v = [0 as u8; 32];
                        values
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                })
            }
        }
        impl substreams_ethereum::Event for Swap {
            const NAME: &'static str = "Swap";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TokensDeregistered {
            pub pool_id: [u8; 32usize],
            pub tokens: Vec<Vec<u8>>,
        }
        impl TokensDeregistered {
            const TOPIC_ID: [u8; 32] = [
                125u8,
                205u8,
                198u8,
                208u8,
                46u8,
                244u8,
                12u8,
                124u8,
                26u8,
                112u8,
                70u8,
                160u8,
                17u8,
                176u8,
                88u8,
                189u8,
                127u8,
                152u8,
                143u8,
                161u8,
                78u8,
                32u8,
                166u8,
                99u8,
                68u8,
                249u8,
                212u8,
                230u8,
                6u8,
                87u8,
                214u8,
                16u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 2usize {
                    return false;
                }
                if log.data.len() < 64usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Address),
                            ),
                        ],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    tokens: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            inner.into_address().expect(INTERNAL_ERR).as_bytes().to_vec()
                        })
                        .collect(),
                })
            }
        }
        impl substreams_ethereum::Event for TokensDeregistered {
            const NAME: &'static str = "TokensDeregistered";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
        #[derive(Debug, Clone, PartialEq)]
        pub struct TokensRegistered {
            pub pool_id: [u8; 32usize],
            pub tokens: Vec<Vec<u8>>,
            pub asset_managers: Vec<Vec<u8>>,
        }
        impl TokensRegistered {
            const TOPIC_ID: [u8; 32] = [
                245u8,
                132u8,
                125u8,
                63u8,
                33u8,
                151u8,
                177u8,
                108u8,
                220u8,
                210u8,
                9u8,
                142u8,
                201u8,
                93u8,
                9u8,
                5u8,
                205u8,
                26u8,
                189u8,
                175u8,
                65u8,
                95u8,
                7u8,
                187u8,
                124u8,
                239u8,
                43u8,
                186u8,
                138u8,
                197u8,
                222u8,
                196u8,
            ];
            pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                if log.topics.len() != 2usize {
                    return false;
                }
                if log.data.len() < 128usize {
                    return false;
                }
                return log.topics.get(0).expect("bounds already checked").as_ref()
                    == Self::TOPIC_ID;
            }
            pub fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                let mut values = ethabi::decode(
                        &[
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Address),
                            ),
                            ethabi::ParamType::Array(
                                Box::new(ethabi::ParamType::Address),
                            ),
                        ],
                        log.data.as_ref(),
                    )
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
                values.reverse();
                Ok(Self {
                    pool_id: {
                        let mut result = [0u8; 32];
                        let v = ethabi::decode(
                                &[ethabi::ParamType::FixedBytes(32usize)],
                                log.topics[1usize].as_ref(),
                            )
                            .map_err(|e| {
                                format!(
                                    "unable to decode param 'pool_id' from topic of type 'bytes32': {:?}",
                                    e
                                )
                            })?
                            .pop()
                            .expect(INTERNAL_ERR)
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    tokens: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            inner.into_address().expect(INTERNAL_ERR).as_bytes().to_vec()
                        })
                        .collect(),
                    asset_managers: values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_array()
                        .expect(INTERNAL_ERR)
                        .into_iter()
                        .map(|inner| {
                            inner.into_address().expect(INTERNAL_ERR).as_bytes().to_vec()
                        })
                        .collect(),
                })
            }
        }
        impl substreams_ethereum::Event for TokensRegistered {
            const NAME: &'static str = "TokensRegistered";
            fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
                Self::match_log(log)
            }
            fn decode(
                log: &substreams_ethereum::pb::eth::v2::Log,
            ) -> Result<Self, String> {
                Self::decode(log)
            }
        }
    }